#!/usr/bin/env bash

# This file is not an executable, it is intended to be sourced by other scripts.
# This file belongs as exactly "{project_root}/scripts/build-functions"
#
# Sourcing this file will set the following variables:
#   OS
#   ARCH
#   JOBS
#   PLATFORM
#   PROJECT_ROOT
#   SOURCE_PLATFORM_ROOT
#   LIBRARIES_PLATFORM_ROOT
#   FRAMEWORKS_ROOT
#   HEADERS_ROOT
#   PACKAGE_DOWNLOAD_DIR
#   PACKAGE_FILE
#   PACKAGE_SOURCE_DIR
#   PACKAGE_ACTION
#
# There are equivalent functions:
#   get_os
#   get_arch
#   get_jobs
#   get_platform
#

# Enforce that this file is sourced, not run.
(return 0 2>/dev/null) || {
    echo "This file is not meant to be run directly."
    exit 1
}

set -u      # Abort on undefined variable.

# Initialise terminal colours
COL_RED=$(tput setaf 1)
COL_GREEN=$(tput setaf 2)
COL_CLEAR=$(tput sgr0)

# Main function executed when this file is sourced.
#
# Sets global variables:
#   PACKAGE_SOURCE_DIR      - Full path to where source will be unpacked.
build_functions_main() {
    # Identify and set the OS/ARCH/JOBS/PLATFORM variables.
    _identify_os_arch

    # Identify common paths: PROJECT_ROOT, PACKAGE_DOWNLOAD_DIR, etc.
    _identify_common_paths

    # Source the package variables.
    _unset_package_variables
    source ./package

    PACKAGE_SOURCE_DIR="${SOURCE_PLATFORM_ROOT}/${NAME}"

    # Ensure all build functions are defined.
    _ensure_build_functions

    # Now parse any arguments passed to the script (may override variables).
    _parse_args "$@"

    # Perform package actions.
    case "${PACKAGE_ACTION}" in
        all)
            deps_all
            fetch && clean_source
            _package_source_missing && unpack
            check_output || build
            ;;
        build)
            fetch && clean_source
            _package_source_missing && unpack
            check_output || build
            ;;
        clean)
            clean_source
            clean_output
            ;;
        clean_all)
            deps_clean_all
            clean_source
            clean_output
            ;;
        *)
            print_error "Unknown action: ${PACKAGE_ACTION}"
            exit 1
            ;;
    esac
}

# --- Helper functions ---

get_os() {
    echo "${OS}"
}

get_arch() {
    echo "${ARCH}"
}

get_jobs() {
    echo "${JOBS}"
}

get_platform() {
    echo "${PLATFORM}"
}

print_plain() {
    if [[ ! -v NAME ]]; then NAME="unknown"; fi
    printf "[${NAME}] %s\n" "$1"
}

print_ok() {
    if [[ ! -v NAME ]]; then NAME="unknown"; fi
    if [[ -t 1 ]]; then # We are in a terminal, use colours.
        printf "[${NAME}] ${COL_GREEN}++${COL_CLEAR} %s\n" "$1"
    else
        printf "[${NAME}] ++ %s\n" "$1"
    fi
}

print_error() {
    if [[ ! -v NAME ]]; then NAME="unknown"; fi
    if [[ -t 1 ]]; then # We are in a terminal, use colours.
        printf "[${NAME}] ${COL_RED}--${COL_CLEAR} %s\n" "$1"
    else
        printf "[${NAME}] !! %s\n" "$1"
    fi
}

# --- "builtin" functions ---

# Fetch source package.
#
# Uses global variables:
#   NAME                    - package variable
#   SOURCE_URL              - package variable
#   SOURCE_HASH             - package variable
#   PACKAGE_DOWNLOAD_DIR
#   SOURCE_PLATFORM_ROOT
#
# Sets global variables:
#   PACKAGE_FILE            - Full path to downloaded package.
#
# Returns 0 (true) if the file was downloaded, 1 if it already exists.
builtin_fetch() {
    local filename
    filename=$(basename "${SOURCE_URL}")

    PACKAGE_FILE="${PACKAGE_DOWNLOAD_DIR}/${filename}"

    # Check if the file already exists.
    if [[ -e "${PACKAGE_DOWNLOAD_DIR}/${filename}" ]]; then
        # Check the hash of the file.
        if ! _check_file_hash "${PACKAGE_DOWNLOAD_DIR}/${filename}" "${SOURCE_HASH}"; then
            # Remove the file.
            rm -f "${PACKAGE_DOWNLOAD_DIR}/${filename}"
        else
            print_ok "Using verified package: ${filename}"
            PACKAGE_FILE="${PACKAGE_DOWNLOAD_DIR}/${filename}"
            return 1
        fi
    fi

    # Download the file.
    print_ok "Downloading package: ${filename}"
    wget -O "${PACKAGE_DOWNLOAD_DIR}/${filename}" "${SOURCE_URL}" -q --show-progress
    local res=$?
    if [[ $res -ne 0 ]]; then
        print_error "Failed to download ${filename}"
        exit 1
    fi

    # Check the hash of the file.
    if ! _check_file_hash "${PACKAGE_DOWNLOAD_DIR}/${filename}" "${SOURCE_HASH}"; then
        print_error "Failed to verify hash of ${filename}"
        exit 1
    fi

    return 0
}

# Unpack source package. Is only called when ${PACKAGE_SOURCE_DIR} is missing.
#
# Uses global variables:
#   PACKAGE_FILE            - from fetch()
#   PACKAGE_SOURCE_DIR      - from fetch()
builtin_unpack() {
    print_error "builtin_unpack() is not implemented"
    exit 1
}

# Clean source package.
#
# Uses global variables:
#   PACKAGE_SOURCE_DIR
#
# Returns 0 (true) when done.
builtin_clean_source() {
    if [[ ! -v PACKAGE_SOURCE_DIR ]] || [[ -z "${PACKAGE_SOURCE_DIR}" ]]; then
        print_error "Cannot clean source, PACKAGE_SOURCE_DIR is not set"
        exit 1
    fi
    print_ok "Cleaning package source."
    rm -rf "${PACKAGE_SOURCE_DIR}"

    return 0
}

# Clean output files.
#
# Uses global variables:
#   LIBRARIES               - package variable
#   FRAMEWORKS              - package variable
#   HEADERS                 - package variable
#   LIBRARIES_PLATFORM_ROOT
#   FRAMEWORKS_ROOT
#   HEADERS_ROOT
builtin_clean_output() {
    print_ok "Cleaning output files."
    for targetname in "${LIBRARIES[@]}"; do
       rm -rf "${LIBRARIES_PLATFORM_ROOT:?}/${targetname}"
    done
    for targetname in "${FRAMEWORKS[@]}"; do
       rm -rf "${FRAMEWORKS_ROOT:?}/${targetname}"
    done
    for targetname in "${HEADERS[@]}"; do
       rm -rf "${HEADERS_ROOT:?}/${targetname}"
    done
}

# Check output files / directories exist. Used to determine if the package
# has been installed.
#
# Uses global variables:
#   PLATFORM
#   LIBRARIES               - package variable
#   FRAMEWORKS              - package variable
#   HEADERS                 - package variable
#   LIBRARIES_PLATFORM_ROOT
#   FRAMEWORKS_ROOT
#   HEADERS_ROOT
#
# Returns 0 (true) if all output exist, 1 if any are missing.
builtin_check_output() {
    local library_result=0
    local framework_result=0
    local header_result=0
    for targetname in "${LIBRARIES[@]}"; do
        if [[ ! -e "${LIBRARIES_PLATFORM_ROOT:?}/${targetname}" ]]; then
            library_result=1
            break
        fi
    done
    for targetname in "${FRAMEWORKS[@]}"; do
        if [[ ! -e "${FRAMEWORKS_ROOT:?}/${targetname}" ]]; then
            framework_result=1
            break
        fi
    done
    for targetname in "${HEADERS[@]}"; do
        if [[ ! -e "${HEADERS_ROOT:?}/${targetname}" ]]; then
            header_result=1
            break
        fi
    done

    if [[ "${PLATFORM}" == 'macOS' ]]; then
        # On macOS at least one of library_result or framework_result
        # must be true for the package to be considered installed.
        local library_or_framework_result=0
        if [[ ${library_result} -ne 0 ]] && [[ ${framework_result} -ne 0 ]]; then
            # Failed both library and framework checks.
            library_or_framework_result=1
        fi

        if [[ ${library_or_framework_result} -ne 0 ]] || [[ ${header_result} -ne 0 ]]; then
            return 1
        fi
    else
        if [[ ${library_result} -ne 0 ]] || [[ ${header_result} -ne 0 ]]; then
            return 1
        fi
    fi

    print_ok "All output files exist."
    return 0    # All checks passed.
}

builtin_deps_all() {
    :
}

builtin_deps_clean_all() {
    :
}

# --- Internal functions ---

_usage() {
    echo ""
    echo "Usage: build.sh [options]"
    echo "  -h, --help      Show this help message."
    echo "  -j n            Number of parallel jobs to use. Default: ${JOBS}"
    echo ""
    echo "  all             Default. Build this package, and dependencies."
    echo "  build           Build only this package, without dependencies."
    echo "  clean           Clean only this package source and output files."
    echo "  clean_all       Clean this package, and dependencies."
    echo ""
}

# Parse command line arguements. Show usage if needed.
#
# Sets global variables:
#   PACKAGE_ACTION
#   JOBS
_parse_args() {
    PACKAGE_ACTION='all'        # Default

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                _usage
                exit 0
                ;;
            -j)
                JOBS="$2"
                shift 2
                ;;
            all|build|clean_all|clean)
                PACKAGE_ACTION="$1"
                shift
                ;;
            *)
                _usage
                echo "!! Unknown argument: $1"
                exit 1
        esac
    done
}

# Check if the given file matches the given hash.
_check_file_hash() {
    local file="$1"
    local hash="$2"

    local hash_type
    local hash_value
    hash_type="${hash%%:*}"
    hash_value="${hash#*:}"

    if [[ ! -e "${file}" ]]; then
        print_error "!! File does not exist: ${file}"
        exit 1
    fi

    local calculated_hash
    case "${hash_type}" in
        SHA256)
            if [[ "${PLATFORM}" == 'macOS' ]]; then
                calculated_hash=$(shasum -a 256 "${file}" | awk '{print $1}')
            else
                calculated_hash=$(sha256sum "${file}" | awk '{print $1}')
            fi
            ;;
        MD5)
            if [[ "${PLATFORM}" == 'macOS' ]]; then
                calculated_hash=$(md5 -q "${file}")
            else
                calculated_hash=$(md5sum "${file}" | awk '{print $1}')
            fi
            ;;
        *)
            print_error "!! Unknown hash type: ${hash_type}"
            exit 1
            ;;
    esac

    if [[ "${calculated_hash}" == "${hash_value}" ]]; then
        return 0
    fi

    return 1
}

# Sets global variables:
#   OS
#   ARCH
#   JOBS
#   PLATFORM
_identify_os_arch() {
    # Identify the OS and architecture.
    OS=$(uname -s)		# Linux|Darwin
    ARCH=$(uname -m)	# x86_64|aarch64|arm64
    JOBS=1              # Number of parallel jobs
    if [[ $OS = 'Darwin' ]]; then
        PLATFORM='macOS'
        JOBS=$(($(sysctl -n hw.logicalcpu) + 1))
    elif [[ $OS = 'Linux' ]]; then
        JOBS=$(($(nproc) + 1))
        if [[ $ARCH = 'aarch64' ]]; then
            PLATFORM='linuxARM'
        elif [[ $ARCH = 'x86_64' ]]; then
            PLATFORM='linux'
        fi
    fi
    if [[ "${PLATFORM}X" = 'X' ]]; then     # $PLATFORM is empty
        echo "!! Unknown OS/ARCH: $OS/$ARCH"
        exit 1
    fi
}

# Sets global variables:
#   PROJECT_ROOT
#   PACKAGE_DOWNLOAD_DIR
#   SOURCE_PLATFORM_ROOT
#   LIBRARIES_PLATFORM_ROOT
#   FRAMEWORKS_ROOT
#   HEADERS_ROOT
#
# shellcheck disable=SC2034
_identify_common_paths() {
    PROJECT_ROOT="$(realpath "$(dirname "${BASH_SOURCE[0]}")/..")"
    PACKAGE_DOWNLOAD_DIR="${PROJECT_ROOT}/source"
    SOURCE_PLATFORM_ROOT="${PROJECT_ROOT}/source/${PLATFORM}"
    LIBRARIES_PLATFORM_ROOT="${PROJECT_ROOT}/Output/Libraries/${PLATFORM}"
    FRAMEWORKS_ROOT="${PROJECT_ROOT}/Output/Frameworks"
    HEADERS_ROOT="${PROJECT_ROOT}/Output/Headers"
}

# Unset all known variables set by package file.
_unset_package_variables() {
    local var_names=(
        NAME
        VERSION
        DESCRIPTION
        SOURCE_URL
        SOURCE_HASH
        DEPS
        LIBRARIES
        FRAMEWORKS
        HEADERS
    )
    for i in "${var_names[@]}"; do
        unset "${i}"
    done
}

# Ensure all build functions are defined.
_ensure_build_functions() {
    build_func_names=(
        fetch
        unpack
        clean_source
        clean_output
        check_output
        deps_all
        deps_clean_all
    )
    for func_name in "${build_func_names[@]}"; do
        if [[ $(type -t $func_name) != function ]]; then
            unset $func_name
            eval "function $func_name() {
                builtin_${func_name} \"\$@\"
                return \$?
            }"
        fi
    done

    # build() function is always required.
    if [[ $(type -t build) != function ]]; then
        print_error "!! build() function is required."
        exit 1
    fi

    # DEBUG - Show all our functions are correctly defined.
    #echo "Check functions:"
    #for func_name in "${build_func_names[@]}" "build"; do
    #    declare -f $func_name
    #done
    #exit 0
}

# Returns true (0) if the package source is missing.
#
# Uses global variables:
#   PACKAGE_SOURCE_DIR
_package_source_missing() {
    if [[ ! -d "${PACKAGE_SOURCE_DIR}" ]]; then
        # Directory does not exist.
        return 0
    fi
    if [[ -z "$( ls -A "${PACKAGE_SOURCE_DIR}" )" ]]; then
        # Directory is empty.
        return 0
    fi
    return 1
}

# End of script, call main function.
build_functions_main "$@"
