#!/usr/bin/env bash

# scripts/build-functions
#   - is not an executable, it is intended to be sourced by other scripts.
#   - belongs as exactly "{project_root}/scripts/build-functions".
#   - must remain compatible with minimum bash version 3.2.57 (macOS).
#
# Sourcing this file will set the following variables:
#   OS                          - Operating system. Linux or Darwin.
#   ARCH                        - Architecture. x86_64, aarch64, or arm64.
#   JOBS                        - Number of parallel jobs.
#   PLATFORM                    - Platform. linux, linuxARM, or macOS.
#
#   PROJECT_ROOT                - The root of the project.
#   SOURCE_PLATFORM_ROOT        - Source directory for this platform.
#   HEADERS_ROOT                - Output directory for headers.
#   LIBRARIES_PLATFORM_ROOT     - Output directory for libraries for this platform.
#   FRAMEWORKS_ROOT             - Output directory for frameworks (macOS only).
#   PACKAGE_NAME                - Dirname of the package.
#   PACKAGE_DOWNLOAD_DIR        - Location to download package source to.
#   PACKAGE_SOURCE_DIR          - Location to unpack source to (includes PACKAGE_NAME).
#   BUILD_LOG                   - Filename to append build log to.
#
#   PACKAGE_FILE                - Full path to downloaded package. Set by fetch()
#   PACKAGE_ACTION              - Action specified on command line when called.

# Enforce that this file is sourced, not run.
(return 0 2>/dev/null) || {
    echo "This file is not meant to be run directly."
    exit 1
}

set -u      # Abort on undefined variables.

# Initialise terminal colours
COL_RED=$(tput setaf 1)
COL_GREEN=$(tput setaf 2)
COL_CLEAR=$(tput sgr0)

# Main function executed when this file is sourced.
#
build_functions_main() {
    # Identify and set the OS/ARCH/JOBS/PLATFORM variables.
    _identify_os_arch

    # Identify common paths: PROJECT_ROOT, SOURCE_PLATFORM_ROOT, etc.
    _identify_common_paths

    # Source the package variables.
    _unset_package_variables
    source ./package

    # Ensure all build functions are defined.
    _ensure_build_functions

    # Now parse any arguments passed to the script (may override variables).
    _parse_args "$@"

    # Perform package actions.
    case "${PACKAGE_ACTION}" in
        all)
            deps_all
            fetch && clean_source
            _package_source_missing && unpack
            check_output || build
            ;;
        build)
            fetch && clean_source
            _package_source_missing && unpack
            check_output || build
            ;;
        clean)
            clean_source
            clean_output
            ;;
        clean-all)
            deps_clean_all
            clean_source
            clean_output
            ;;
        *)
            print_error "Unknown action: ${PACKAGE_ACTION}"
            exit 1
            ;;
    esac
}

# --- Helper functions ---

# Print a formatted message to stdout. No colours.
#
# $1 - Message to print.
print_plain() {
    if [[ ! -v PACKAGE_NAME ]]; then PACKAGE_NAME="unknown"; fi
    printf "[${PACKAGE_NAME}]    %s\n" "$1"
}

# Print a formatted message to stdout. Uses green to signify success.
#
# $1 - Message to print.
print_ok() {
    if [[ ! -v PACKAGE_NAME ]]; then PACKAGE_NAME="unknown"; fi
    if [[ -t 1 ]]; then # We are in a terminal, use colours.
        printf "[${PACKAGE_NAME}] ${COL_GREEN}++${COL_CLEAR} %s\n" "$1"
    else
        printf "[${PACKAGE_NAME}] ++ %s\n" "$1"
    fi
}

# Print a formatted message to stdout. Uses red to signify an error.
#
# $1 - Message to print.
print_error() {
    if [[ ! -v PACKAGE_NAME ]]; then PACKAGE_NAME="unknown"; fi
    if [[ -t 1 ]]; then # We are in a terminal, use colours.
        printf "[${PACKAGE_NAME}] ${COL_RED}--${COL_CLEAR} %s\n" "$1"
    else
        printf "[${PACKAGE_NAME}] !! %s\n" "$1"
    fi
}

# Pretty print a time in seconds, in the format H:MM:SS.
#
# $1 - Time in seconds.
pretty_time() {
    local S=$1
    local H=$((S/3600))
    local M=$((S/60%60))
    local S=$((S%60))
    printf '%01d:%02d:%02d' $H $M $S
}

# Wait on supplied child process to complete, giving a progress indicator.
#
# $1 - PID of child process.
#
# Returns the exit code of the child process.
wait_progress() {
    local pid="$1"

    local start_time
    start_time=$(date +%s)

    if [[ -t 1 ]]; then
        # We are in a terminal, we can animate progress
        local throbber='-\|/'
        local i=0
        while kill -0 $pid 2>/dev/null; do
            i=$(( (i+1) % ${#throbber} ))
            printf "\r[${PACKAGE_NAME}] %s " "${throbber:$i:1}"
            sleep 0.5
        done
        printf "\r"
    else
        # We are not in a terminal, use plain output.
        # Output 60 dots, 5 seconds apart on a line =~ 5 mins
        # Newline every 60 dots with a prefix of the approx mins
        local dots=0
        local approx_mins=0
        printf "[0]"
        while kill -0 $pid 2>/dev/null; do
            dots=$(( (dots+1) % 60 ))
            if [[ $dots -eq 0 ]]; then
                approx_mins=$(( approx_mins+5 ))
                printf "\n[%s]" "${approx_mins}"
            fi
            printf "."
            sleep 5
        done
        printf "\n"
    fi

    wait "$pid"
    local rc=$?

    local stop_time
    stop_time=$(date +%s)

    local str_time
    str_time=$(pretty_time $((stop_time - start_time)))
    print_plain "Elapsed time: $str_time"

    return $rc
}

# --- "builtin" functions ---

# Fetch source package.
#
# Uses global variables:
#   PACKAGE_NAME                    - package variable
#   SOURCE_URL              - package variable
#   SOURCE_HASH             - package variable
#   PACKAGE_DOWNLOAD_DIR
#   SOURCE_PLATFORM_ROOT
#
# Sets global variables:
#   PACKAGE_FILE            - Full path to downloaded package.
#
# Returns 0 (true) if the file was downloaded, 1 if it already exists.
builtin_fetch() {
    local filename
    filename=$(basename "${SOURCE_URL}")

    # shellcheck disable=SC2034
    PACKAGE_FILE="${PACKAGE_DOWNLOAD_DIR}/${filename}"

    # Check if the file already exists.
    if [[ -e "${PACKAGE_DOWNLOAD_DIR}/${filename}" ]]; then
        # Check the hash of the file.
        if ! _check_file_hash "${PACKAGE_DOWNLOAD_DIR}/${filename}" "${SOURCE_HASH}"; then
            # Remove the file.
            rm -f "${PACKAGE_DOWNLOAD_DIR}/${filename}"
        else
            print_ok "Using verified package: ${filename}"
            return 1
        fi
    fi

    # Download the file.
    print_ok "Downloading package: ${filename}"
    wget -O "${PACKAGE_DOWNLOAD_DIR}/${filename}" "${SOURCE_URL}" -q --show-progress
    local res=$?
    if [[ $res -ne 0 ]]; then
        print_error "Failed to download ${filename}"
        exit 1
    fi

    # Check the hash of the file.
    if ! _check_file_hash "${PACKAGE_DOWNLOAD_DIR}/${filename}" "${SOURCE_HASH}"; then
        print_error "Failed to verify hash of ${filename}"
        exit 1
    fi

    return 0
}

# Unpack source package. Is only called when ${PACKAGE_SOURCE_DIR} is missing.
#
# Uses global variables:
#   PACKAGE_FILE            - from fetch()
builtin_unpack() {
    :
}

builtin_build() {
    :
}

# Clean source package.
#
# Uses global variables:
#   PACKAGE_SOURCE_DIR
#
# Returns 0 (true) when done.
builtin_clean_source() {
    if [[ ! -v PACKAGE_SOURCE_DIR ]] || [[ -z "${PACKAGE_SOURCE_DIR}" ]]; then
        print_error "Cannot clean source, PACKAGE_SOURCE_DIR is not set"
        exit 1
    fi
    print_ok "Cleaning package source."
    rm -rf "${PACKAGE_SOURCE_DIR}"
    rm -rf "${BUILD_LOG}"

    return 0
}

# Clean output files.
#
# Uses global variables:
#   LIBRARIES               - package variable
#   FRAMEWORKS              - package variable
#   HEADERS                 - package variable
#   LIBRARIES_PLATFORM_ROOT
#   FRAMEWORKS_ROOT
#   HEADERS_ROOT
builtin_clean_output() {
    print_ok "Cleaning output files."
    for targetname in "${LIBRARIES[@]}"; do
       rm -rf "${LIBRARIES_PLATFORM_ROOT:?}/${targetname}"
    done
    for targetname in "${FRAMEWORKS[@]}"; do
       rm -rf "${FRAMEWORKS_ROOT:?}/${targetname}"
    done
    for targetname in "${HEADERS[@]}"; do
       rm -rf "${HEADERS_ROOT:?}/${targetname}"
    done
}

# Check output files / directories exist. Used to determine if the package
# has been installed.
#
# Uses global variables:
#   PLATFORM
#   LIBRARIES               - package variable
#   FRAMEWORKS              - package variable
#   HEADERS                 - package variable
#   LIBRARIES_PLATFORM_ROOT
#   FRAMEWORKS_ROOT
#   HEADERS_ROOT
#
# Returns 0 (true) if all output exist, 1 if any are missing.
builtin_check_output() {
    local library_result=0
    local framework_result=0
    local header_result=0
    for targetname in "${LIBRARIES[@]}"; do
        if [[ ! -e "${LIBRARIES_PLATFORM_ROOT:?}/${targetname}" ]]; then
            library_result=1
            break
        fi
    done
    for targetname in "${HEADERS[@]}"; do
        if [[ ! -e "${HEADERS_ROOT:?}/${targetname}" ]]; then
            header_result=1
            break
        fi
    done
    for targetname in "${FRAMEWORKS[@]}"; do
        if [[ ! -e "${FRAMEWORKS_ROOT:?}/${targetname}" ]]; then
            framework_result=1
            break
        fi
    done

    if [[ "${PLATFORM}" == 'macOS' ]]; then
        # On macOS, at least:
        #   library_result AND header_result
        #   OR
        #   framework_result
        # must be true for the package to be considered installed.
        if [[ ${library_result} -ne 0 ]] || [[ ${header_result} -ne 0 ]]; then
            # library or header failed
            if [[ ${framework_result} -ne 0 ]]; then
                # framework failed
                return 1
            fi
        fi
    else
        if [[ ${library_result} -ne 0 ]] || [[ ${header_result} -ne 0 ]]; then
            return 1
        fi
    fi

    print_ok "All output files exist."
    return 0    # All checks passed.
}

builtin_deps_all() {
    :
}

builtin_deps_clean_all() {
    :
}

# --- Internal functions ---

_usage() {
    echo ""
    echo "Usage: build.sh [options]"
    echo "  -h, --help      Show this help message."
    echo "  -j n            Number of parallel jobs to use. Default: ${JOBS}"
    echo ""
    echo "  all             Default. Build this package, and dependencies."
    echo "  build           Build only this package, without dependencies."
    echo "  clean           Clean only this package source and output files."
    echo "  clean-all       Clean this package, and dependencies."
    echo ""
}

# Parse command line arguements. Show usage if needed.
#
# Sets global variables:
#   PACKAGE_ACTION
#   JOBS
_parse_args() {
    PACKAGE_ACTION='all'        # Default

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                _usage
                exit 0
                ;;
            -j)
                JOBS="$2"
                shift 2
                ;;
            all|build|clean-all|clean)
                PACKAGE_ACTION="$1"
                shift
                ;;
            *)
                _usage
                echo "!! Unknown argument: $1"
                exit 1
        esac
    done
}

# Check if the given file matches the given hash.
_check_file_hash() {
    local file="$1"
    local hash="$2"

    local hash_type
    local hash_value
    hash_type="${hash%%:*}"
    hash_value="${hash#*:}"

    if [[ ! -e "${file}" ]]; then
        print_error "!! File does not exist: ${file}"
        exit 1
    fi

    local calculated_hash
    case "${hash_type}" in
        SHA256)
            if [[ "${PLATFORM}" == 'macOS' ]]; then
                calculated_hash=$(shasum -a 256 "${file}" | awk '{print $1}')
            else
                calculated_hash=$(sha256sum "${file}" | awk '{print $1}')
            fi
            ;;
        MD5)
            if [[ "${PLATFORM}" == 'macOS' ]]; then
                calculated_hash=$(md5 -q "${file}")
            else
                calculated_hash=$(md5sum "${file}" | awk '{print $1}')
            fi
            ;;
        *)
            print_error "!! Unknown hash type: ${hash_type}"
            exit 1
            ;;
    esac

    if [[ "${calculated_hash}" == "${hash_value}" ]]; then
        return 0
    fi

    return 1
}

# Sets global variables:
#   OS
#   ARCH
#   JOBS
#   PLATFORM
_identify_os_arch() {
    # Identify the OS and architecture.
    OS=$(uname -s)		# Linux|Darwin
    ARCH=$(uname -m)	# x86_64|aarch64|arm64
    JOBS=1              # Number of parallel jobs
    if [[ $OS = 'Darwin' ]]; then
        PLATFORM='macOS'
        JOBS=$(($(sysctl -n hw.logicalcpu) + 1))
    elif [[ $OS = 'Linux' ]]; then
        JOBS=$(($(nproc) + 1))
        if [[ $ARCH = 'aarch64' ]]; then
            PLATFORM='linuxARM'
        elif [[ $ARCH = 'x86_64' ]]; then
            PLATFORM='linux'
        fi
    fi
    if [[ "${PLATFORM}X" = 'X' ]]; then     # $PLATFORM is empty
        echo "!! Unknown OS/ARCH: $OS/$ARCH"
        exit 1
    fi
}

# Sets global variables:
#   PROJECT_ROOT                - derived from this sourced script's location
#   SOURCE_PLATFORM_ROOT        - calculated from PROJECT_ROOT + PLATFORM
#   HEADERS_ROOT                - derived from PROJECT_ROOT
#   LIBRARIES_PLATFORM_ROOT     - calculated from PROJECT_ROOT + PLATFORM
#   FRAMEWORKS_ROOT             - derived from PROJECT_ROOT
#   PACKAGE_NAME                - derived from sourcing script's location
#   PACKAGE_DOWNLOAD_DIR        - calculated from PROJECT_ROOT
#   PACKAGE_SOURCE_DIR          - calculated from SOURCE_PLATFORM_ROOT + PACKAGE_NAME
#   BUILD_LOG                   - calculated from SOURCE_PLATFORM_ROOT + PACKAGE_NAME
#
_identify_common_paths() {
    PROJECT_ROOT="$(realpath "$(dirname "${BASH_SOURCE[0]}")/..")"
    SOURCE_PLATFORM_ROOT="${PROJECT_ROOT}/source/${PLATFORM}"
    HEADERS_ROOT="${PROJECT_ROOT}/Output/Headers"
    LIBRARIES_PLATFORM_ROOT="${PROJECT_ROOT}/Output/Libraries/${PLATFORM}"
    FRAMEWORKS_ROOT="${PROJECT_ROOT}/Output/Frameworks"
    PACKAGE_NAME="$(basename "$(dirname "$(realpath "$0")")")"
    PACKAGE_DOWNLOAD_DIR="${PROJECT_ROOT}/source"
    PACKAGE_SOURCE_DIR="${SOURCE_PLATFORM_ROOT}/${PACKAGE_NAME}"
    BUILD_LOG="${SOURCE_PLATFORM_ROOT}/${PACKAGE_NAME}.log"
}

# Unset all known variables set by package file.
_unset_package_variables() {
    local var_names=(
        DESCRIPTION
        DEPENDENCIES
        SOURCE_URL
        SOURCE_HASH
        LIBRARIES
        FRAMEWORKS
        HEADERS
    )
    for i in "${var_names[@]}"; do
        unset "${i}"
    done
}

# Ensure all build functions are defined.
_ensure_build_functions() {
    build_func_names=(
        fetch
        unpack
        build
        clean_source
        clean_output
        check_output
        deps_all
        deps_clean_all
    )
    for func_name in "${build_func_names[@]}"; do
        if [[ $(type -t $func_name) != function ]]; then
            unset $func_name
            eval "
                function $func_name() {
                    builtin_${func_name} \"\$@\"
                    return \$?
                }
            "
        fi
    done

    # DEBUG - Show all our functions are correctly defined.
    #echo "Check functions:"
    #for func_name in "${build_func_names[@]}" "build"; do
    #    declare -f $func_name
    #done
    #exit 0
}

# Returns true (0) if the package source is missing.
#
# Uses global variables:
#   PACKAGE_SOURCE_DIR
_package_source_missing() {
    if [[ ! -d "${PACKAGE_SOURCE_DIR}" ]]; then
        # Directory does not exist.
        return 0
    fi
    if [[ -z "$( ls -A "${PACKAGE_SOURCE_DIR}" )" ]]; then
        # Directory is empty.
        return 0
    fi
    return 1
}

# End of script, call main function.
build_functions_main "$@"
